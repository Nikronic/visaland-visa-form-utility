from typing import Any, Callable, List, Mapping, Optional

from snorkel.map import BaseMapper
from snorkel.preprocess import BasePreprocessor
from snorkel.types import DataPoint


class TransformationFunction:
    """Base classes for transformation functions.

    A transformation function (TF) represents an atomic transformation
    to a data point in a data augmentation pipeline. Common examples in
    image processing include small image rotations or crops. Snorkel
    models data augmentation as a sequence of TFs generated by a policy.

    This class wraps a Python function outputting a data point. Extra
    functionality, such as running preprocessors and storing
    resources, is provided. Simple TFs can be defined via a
    decorator. See ``transformation_function``.

    Parameters
    ----------
    name
        Name of the TF
    f
        Function that implements the core TF logic
    resources
        Transformation resources passed in to ``f`` via ``kwargs``
    pre
        Preprocessors to run on data points before TF execution

    Raises
    ------
    ValueError
        Calling incorrectly defined preprocessors

    Attributes
    ----------
    name
        See above
    """

    def __init__(
        self,
        name: str,
        f: Callable[..., int],
        resources: Optional[Mapping[str, Any]] = None,
        pre: Optional[List[BasePreprocessor]] = None,
    ) -> None:
        self.name = name
        self._f = f
        self._resources = resources or {}
        self._pre = pre or []

    def _preprocess_data_point(self, x: DataPoint) -> DataPoint:
        for preprocessor in self._pre:
            x = preprocessor(x)
            if x is None:
                raise ValueError("Preprocessor should not return None")
        return x

    def __call__(self, x: DataPoint) -> int:
        """Transform data point.

        Runs all preprocessors, then passes preprocessed data point to TF.

        Parameters
        ----------
        x
            Data point to transform

        Returns
        -------
        int
            Transformed data point
        """
        x = self._preprocess_data_point(x)
        return self._f(x, **self._resources)

    def __repr__(self) -> str:
        preprocessor_str = f", Preprocessors: {self._pre}"
        return f"{type(self).__name__} {self.name}{preprocessor_str}"


class transformation_function:
    """Decorator to define a TransformationFunction object from a function.

    Parameters
    ----------
    name
        Name of the TF
    resources
        Transformation resources passed in to ``f`` via ``kwargs``
    pre
        Preprocessors to run on data points before TF execution

    Examples
    --------
    Example
    -------
    >>> @transformation_function()
    ... def square(x):
    ...     x.num = x.num ** 2
    ...     return x
    >>> from types import SimpleNamespace
    >>> square(SimpleNamespace(num=2))
    namespace(num=4)
    0

    >>> @transformation_function(name="my_tf")
    ... def square(x):
    ...     x.num = x.num ** 2
    ...     return x
    >>> square
    TransformationFunction my_tf, Preprocessors: []
    """

    def __init__(
        self,
        name: Optional[str] = None,
        resources: Optional[Mapping[str, Any]] = None,
        pre: Optional[List[BasePreprocessor]] = None,
    ) -> None:
        if callable(name):
            raise ValueError(
                "Looks like this decorator is missing parentheses!")
        self.name = name
        self.resources = resources
        self.pre = pre

    def __call__(self, f: Callable[..., int]) -> TransformationFunction:
        """Wrap a function to create a ``TransformationFunction``.

        Parameters
        ----------
        f
            Function that implements the core TF logic

        Returns
        -------
        TransformationFunction
            New ``TransformationFunction`` executing logic in wrapped function
        """
        name = self.name or f.__name__
        return TransformationFunction(name=name, f=f, resources=self.resources, pre=self.pre)
